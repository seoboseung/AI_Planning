# AI Planning 보고서
## 학급 배정 최적화 시스템 (Class Assignment Optimization System)

---

## 목차
1. [문제 정의](#문제-정의)
2. [생각 과정](#생각-과정)
3. [시스템 설계](#시스템-설계)
4. [제약조건 분석](#제약조건-분석)
5. [구현 과정](#구현-과정)
6. [코드 설명](#코드-설명)
7. [실험 결과](#실험-결과)

---

## 문제 정의

### 문제 상황
200명의 학생을 6개 학급(33명×4반, 34명×2반)으로 배정하는 문제로, 다음과 같은 복합적인 제약조건들을 동시에 만족해야 합니다:

1. **적대관계 분리**: 서로 사이가 좋지 않은 학생들은 같은 반에 배정하지 않음
2. **전년도 클래스메이트 분산**: 전년도 같은 반이었던 학생들이 한 반에 몰리지 않게 분산
3. **리더십 균등 분배**: 리더십이 있는 학생이 각 반에 최소 1명씩 배정
4. **피아노 학생 균등 분배**: 피아노 연주 가능한 학생들을 각 반에 균등하게 분배
5. **성적 균형**: 각 반의 평균 성적이 비슷하게 유지
6. **비등교생 균등 분배**: 등교 거부 성향 학생들을 각 반에 균등하게 분배
7. **성별 균형**: 남녀 비율을 각 반에 균등하게 분배
8. **운동 능력 균등 분배**: 운동을 선호하는 학생들을 각 반에 균등하게 분배
9. **클럽 활동 다양성**: 10개 클럽 종류(노래, 댄스, 야구, 미술, 밴드, 축구, 코딩, 연극, 봉사, 독서)의 멤버들을 각각 균등하게 분배하여 모든 반이 다양한 클럽 활동을 보유

### 문제의 복잡성
- **NP-Hard 문제**: 조합 최적화 문제로 변수의 수가 기하급수적으로 증가
- **다중 제약조건**: 9개의 서로 다른 제약조건이 상호작용
- **하드/소프트 제약 혼재**: 일부는 반드시 만족해야 하고, 일부는 최적화 목표

---

## 생각 과정

### 1단계: 문제 분석
처음에는 단순한 배정 문제로 생각했지만, 다음과 같은 복잡성을 발견:
- **제약조건 불가능**: 전년도 클래스 메이트를 모두 분리 할 수 없음
- **제약조건 기준 불명확**: 성적순이라는 조건이 평균이 같으면 되는건지 점수 총합이 같으면 되는지 불명확함.

### 2단계: 접근 방법 선택
여러 알고리즘을 고려한 결과:
- **Greedy Algorithm**: 빠르지만 최적해 보장 안 됨
- **Genetic Algorithm**: 복잡하고 수렴 보장 어려움
- **OR-Tools CP-SAT**: 제약조건 처리에 특화, 최적해 보장

**→ OR-Tools CP-SAT 선택**

### 3단계: 점진적 개발 전략
모든 제약조건을 한 번에 구현하면 디버깅이 어려워서 점진적 접근 채택:
- Step 1: 기본 제약조건 (배정, 인원, 적대관계)
- Step 2: 리더십 분배 추가
- Step 3: 피아노 학생 분배 추가
- ...
- Step 11: 모든 제약조건 완성

### 4단계: 제약조건 분류
효과적인 구현을 위해 제약조건을 분류:
- **하드 제약 (Hard Constraints)**: 반드시 만족해야 함
- **소프트 제약 (Soft Constraints)**: 목적함수로 최적화

---

## 시스템 설계

### 아키텍처 개요
```
CSV Data → Data Processing → OR-Tools CP-SAT → Optimization → Results
    ↓            ↓                ↓              ↓           ↓
  학생정보    정규화/매핑      제약조건 생성    목적함수 최적화   배정결과
```

### 핵심 구성 요소
1. **데이터 전처리 모듈**: CSV 파싱, 데이터 정규화
2. **제약조건 생성기**: 각 제약조건을 OR-Tools 제약으로 변환
3. **최적화 엔진**: CP-SAT 솔버를 사용한 최적해 탐색
4. **결과 분석기**: 배정 결과의 품질 평가 및 시각화

---

## 제약조건 분석

### 하드 제약조건 (Hard Constraints)
**1. 기본 배정 제약**
```python
# 각 학생은 정확히 하나의 학급에 배정
for i in range(n):
    model.Add(sum(x[(i,c)] for c in range(k)) == 1)

# 각 학급의 정확한 인원수 유지
for c in range(k):
    model.Add(sum(x[(i,c)] for i in range(n)) == class_sizes[c])
```

**2. 적대관계 분리**
```python
for i in range(n):
    for j in enemies_list[i]:
        for c in range(k):
            model.Add(x[(i,c)] + x[(j,c)] <= 1)  # 같은 반 배정 금지
```

**3. 리더십 학생 분배**
```python
# 각 반에 최소 1명의 리더십 학생 배정
for c in range(k):
    model.Add(sum(x[(i,c)] for i in leadership_students) >= 1)
```

**4. 피아노/비등교/운동 학생 균등 분배**
```python
# 특수 속성 학생들을 각 반에 3-4명씩 균등 분배
for attribute_group in [piano_students, at_risk_students, athletic_students]:
    total = len(attribute_group)
    floor_count = total // k
    ceil_count = math.ceil(total / k)
    for c in range(k):
        model.Add(sum(x[(i,c)] for i in attribute_group) >= floor_count)
        model.Add(sum(x[(i,c)] for i in attribute_group) <= ceil_count)
```

**5. 성별 균형**
```python
# 남학생을 각 반에 23-24명씩 배정 (여학생은 자동으로 균형)
male_total = len(male_students)
male_floor = male_total // k
male_ceil = math.ceil(male_total / k)
for c in range(k):
    model.Add(sum(x[(i,c)] for i in male_students) >= male_floor)
    model.Add(sum(x[(i,c)] for i in male_students) <= male_ceil)
```

**6. 클럽별 다양성 보장**
```python
# 각 클럽 종류별로 개별 균등 분배 (10개 클럽 타입)
for club_name, club_members in club_groups.items():
    club_total = len(club_members)
    club_floor = club_total // k
    club_ceil = math.ceil(club_total / k)
    for c in range(k):
        model.Add(sum(x[(i,c)] for i in club_members) >= club_floor)
        model.Add(sum(x[(i,c)] for i in club_members) <= club_ceil)
```

### 소프트 제약조건 (Soft Constraints)
**1. 전년도 클래스 분산**
```python
# 한 반에 전년도 동일 클래스 출신이 너무 몰리지 않게
max_per_class = math.ceil(len(students) / k) + 1
over_var = model.NewIntVar(0, len(students), f"prev_over_{prev_class}_{c}")
model.Add(over_var >= sum(x[(i,c)] for i in students) - max_per_class)
```

**2. 성적 균형**
```python
# 각 반의 성적 편차 최소화
max_deviation = model.NewIntVar(0, total_grade, 'max_deviation')
for c in range(k):
    model.Add(class_grade_sum[c] - target_grade_per_class <= max_deviation)
    model.Add(target_grade_per_class - class_grade_sum[c] <= max_deviation)
```

---

## 구현 과정

### Phase 1: 데이터 전처리
**데이터 구조 분석**:
- 학생 정보: 200명의 완전한 데이터셋
- 적대관계: 20건의 명확한 관계 데이터
- 전년도 학급: 6개 학급(a~f반) 출신 정보
- 속성 정보: 리더십, 피아노, 비등교, 성별, 운동, 클럽 등 완비

**구현된 유틸리티 함수**:
```python
def find_col(cols, possible_names):
    # 다양한 컬럼명 패턴에 대응하는 범용 함수
    for name in possible_names:
        if name in cols:
            return name
    for col in cols:
        if col.lower() in [name.lower() for name in possible_names]:
            return col

def normalize_bool(x):
    # 불린 값 정규화 (0/1 변환)
    if pd.isna(x): return 0
    s = str(x).strip().lower()
    return 1 if s in ('1','yes','y','true','있음','리더') else 0
```

### Phase 2: 점진적 제약조건 추가
각 단계마다 독립적인 파일 생성으로 디버깅 용이:
- `class_assignment_step3.py`: 기본 제약
- `class_assignment_step4.py`: 리더십 추가
- ...
- `class_assignment_final.py`: 모든 제약 통합

### Phase 3: 성능 최적화
**문제**: 전년도 클래스메이트 완전 분리 시도
- 24년 학급별 학생 수: a반(36명), b반(35명), c반(35명), d반(36명), e반(26명), f반(32명)
- 모든 전년도 클래스메이트를 완전히 분리하려면 **36개의 반이 필요** (최대 출신 반 기준)
- 현재 6개 반으로는 수학적으로 불가능하여 INFEASIBLE 결과

**해결책**: 하드 제약에서 소프트 제약으로 변경
```python
# 변경 전: 모든 전년도 클래스메이트 쌍 분리 (하드 제약 - INFEASIBLE)
for i, j in all_previous_pairs:
    for c in range(k):
        model.Add(x[(i,c)] + x[(j,c)] <= 1)

# 변경 후: 각 반에 동일 출신이 너무 몰리지 않게 분산 (소프트 제약)
max_per_class = math.ceil(len(students) / k) + 1  # 각 반 최대 6-7명
over_var = model.NewIntVar(0, len(students), f"prev_over_{prev_class}_{c}")
model.Add(over_var >= sum(x[(i,c)] for i in students) - max_per_class)
model.Minimize(sum(all_over_vars))  # 목적함수에 추가하여 최적화
```



---


### 데이터 구조
```python
# 학생 정보 구조
Student = {
    'id': '202501',
    'name': 'Andy',
    'gender': 'boy',
    'score': 90,
    'previous_class': 'a',
    'club': '노래',
    'enemies': ['202502', '202503'],
    'leadership': True,
    'piano': False,
    'at_risk': False,
    'athletic': False
}
```

---

## 코드 설명

### 핵심 함수 분석

**1. 메인 실행 함수**
```python
def run_ortools_final(students_df, class_sizes):
    """
    OR-Tools CP-SAT를 사용한 최종 학급 배정 최적화
    - 9개의 제약조건을 모두 적용
    - 하드 제약과 소프트 제약을 조합
    - OPTIMAL 해 탐색
    """
```

**2. 데이터 전처리 함수**
```python
def find_col(cols, possible_names):
    """다양한 컬럼명 패턴 매칭"""
    
def normalize_bool(x):
    """다양한 불린 표현 정규화"""
    
def build_previous_classmates(df, prev_class_col):
    """전년도 클래스 관계 구축"""
```

**3. 제약조건 생성 함수들**
- `add_enemy_constraints()`: 적대관계 분리
- `add_previous_class_distribution()`: 전년도 클래스 분산
- `add_attribute_balance()`: 속성별 균등 분배
- `add_club_diversity()`: 클럽별 다양성 보장
- `add_grade_balance()`: 성적 균형 최적화

### 최적화 전략
1. **변수 정의**: 200×6 이진 변수 행렬
2. **제약조건 우선순위**: 하드 제약 → 소프트 제약
3. **목적함수**: 성적 편차 최소화 + 전년도 분산 최적화
4. **솔버 설정**: CP-SAT의 기본 설정으로 충분한 성능

---

## 실험 결과

### 최종 성능 지표
- **솔버 상태**: OPTIMAL (최적해 달성)
- **실행 시간**: 약 30-60초
- **변수 수**: 1,200개 (200명 × 6반)
- **제약조건 수**: 약 300여 개

### 제약조건별 만족도

| 제약조건 | 목표 | 달성 결과 | 성과 |
|---------|------|-----------|------|
| 적대관계 분리 | 100% | 100% |  완벽 |
| 전년도 클래스 분산 | 각 반 최대 6-7명 | 모든 반 만족 |  완벽 |
| 리더십 분배 | 각 반 최소 1명 | 1-7명 분포 |  완벽 |
| 피아노 학생 분배 | 3-4명씩 | 3-4명씩 |  완벽 |
| 성적 균형 | 편차 최소화 | 표준편차 0.0 |  완벽 |
| 비등교생 분배 | 3-4명씩 | 3-4명씩 |  완벽 |
| 성별 균형 | 23-24명씩 | 23-24명씩 |  완벽 |
| 운동 능력 분배 | 3-4명씩 | 3-4명씩 |  완벽 |
| 클럽 다양성 | 각 클럽 균등 분배 | 10종류 클럽 모든 반 보유 |  완벽 |

### 세부 결과 분석

**1. 성적 균형 (완벽 달성)**
```
학급 0: 33명, 총점 2631 (평균 79.7)
학급 1: 33명, 총점 2631 (평균 79.7)  
학급 2: 33명, 총점 2631 (평균 79.7)
학급 3: 33명, 총점 2631 (평균 79.7)
학급 4: 34명, 총점 2631 (평균 77.4)
학급 5: 34명, 총점 2631 (평균 77.4)
성적 총점 표준편차: 0.0 (완벽한 균형)
```

**2. 클럽 다양성 (모든 반에 10종류 클럽)**
```
연극 클럽 (26명): 반0:4명, 반1:4명, 반2:4명, 반3:4명, 반4:5명, 반5:5명
미술 클럽 (25명): 반0:4명, 반1:4명, 반2:5명, 반3:4명, 반4:4명, 반5:4명
밴드 클럽 (21명): 반0:4명, 반1:4명, 반2:3명, 반3:3명, 반4:3명, 반5:4명
축구 클럽 (21명): 반0:4명, 반1:3명, 반2:4명, 반3:3명, 반4:4명, 반5:3명
야구 클럽 (20명): 반0:3명, 반1:4명, 반2:3명, 반3:4명, 반4:3명, 반5:3명
```

**3. 전년도 클래스 분산**
```
전년도 a반 출신 (36명): 각 반 최대 7명 이하로 분산
전년도 b반 출신 (35명): 각 반 최대 7명 이하로 분산
전년도 c반 출신 (35명): 각 반 최대 7명 이하로 분산
...
```

### 성능 개선 과정
| 버전 | 문제점 | 해결책 | 결과 |
|------|--------|--------|------|
| Step 3-8 | 복잡한 제약으로 FEASIBLE | 점진적 추가 | OPTIMAL |
| 초기 Final | 전년도 분리 INFEASIBLE | 하드→소프트 제약 | FEASIBLE |
| 최종 Final | 성적 균형 최적화 | 총점 기준 균형화 | OPTIMAL, 편차 0.0 |

---


